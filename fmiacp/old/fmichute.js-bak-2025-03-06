//LIBRARIES
const cp = require('child_process');
const EventSource = require('eventsource');
var sql = require("mssql");
const config = require('config');
const dayjs = require('dayjs');
var utc = require('dayjs/plugin/utc');
dayjs.extend(utc);
const https = require('https');
const axios = require('axios');
//Web API Stuff
const express = require('express'); //npm install express
const bodyParser = require('body-parser'); // npm install body-parser
const http = require('http');
const filter = require("mrc-filter");
const utils = require("mrc-utils");
//SITE VARIABLES
const vFLTServer = config.get('FLTServer');
const vMRCServerAuth = config.get('MRCServerAuth');
const vFLTServerAuth = config.get('FLTServerAuth'); //`Basic bWNoYW1iZXI6ODAwMTYzNTc=`
var dbConfig = config.get('dbConfig');
var dbConfig2 = config.get('momsdbConfig');
const vFMIChutePort = config.get('FMIChutePort');
const fs = require('fs');
const csv = require("csv-parser");
//STATIC VARIABLES - SETTINGS
var APP_VERSION = "1.3";
//const vDoSyncInterval = 30000;
const vLoadDataInterval = 30000;
var vReadQSize = 50;
var reconnectFrequencySeconds = 1;
var evtSource;
var PORT = process.env.PORT || vFMIChutePort;
//var vCurrentMachine = new Map();
//var vFLTMachineMap = new Map();

var vMAPFMIChuteHistoricalData = new Map();
//var vMOMSChuteData = new Map();
//var vMAPFMIChuteHistoricalDataCurrent = new Map();
//var vMAPFMIChuteHistoricalDataCurrentCalc = new Map();
var vFLTChuteStaticData = new Map();
//var vFMIChuteData= new Map();
var vCompleteChuteData = new Map();
var filename = "ChuteData.csv";

//FUNCTIONS
async function startDBConnect() {
    try {
        await dbConn.connect();
        await dbConn2.connect();
    } catch (err) {
        console.log("FMICHUTE:STARTDBCONNECT:CONNECTION-ERROR:" + err);
    };
    console.log("FMICHUTE:STARTDBCONNECT:Starting process to load/save MineStar Chute data...");
    //await loadMOMSChuteData();
    //await loadCSVChuteStaticData();
    await loadData();
    await loadHistoryData();
}

/*async function loadCSVChuteStaticData(){
	console.log("FMICHUTE:LOADCSVCHUTESTATICDATA:Loading Chute csv Details File...");
                //var vRBTempMap = new Map();
                try {
                        var rs = await fs.createReadStream(filename)
                        .pipe(csv({ separator: ',' , headers: ['Chute_ID','Chute_Name','Chute_Group','Chute_Sensor','Site_Code','Site_Name','Panel_ID','Panel_Name','Sensor_Level','Max_Sensor_Level','Alias_Chute','Alias_Mstar','Alias_Midroc','Position','Is_Active','UTC_Modified_Date','Modified_By'] }))
                        .on('data', (data) => {
                                vFLTChuteStaticData.set(data.Alias_Midroc,data);
                                //vMachineData.push(vMachine);
                                vDataInputCount++;
                        })
                        .on('end', () => {
                                //vChangesData=[].concat(vTmpData);
                                console.log("FMICHUTE:LOADCSVCHUTESTATICDATA:File Load Complete("+vFLTChuteStaticData.size+").");
                                //vRBMap= new Map(vRBTempMap);
                        });
                } catch (e) {
                        console.error(e); // should contain code (exit code) and signal (that caused the termination).
                }
}*/

var vFLTChuteDumped = new Map(); //Stores Dumped amount.
var vOPCUAChuteSensor = new Map();
var vMOMSChuteTaken = new Map(); //Stores Taken amount.
var vFMIChuteAdjustment = new Map(); //Stores the Adjustments done in this shift.
var vFMIChuteData = new Map(); //Stores The Fleet APi Data.
var vCPUPercent = 0;
var vlastCPU = process.cpuUsage();
var vlastTime = process.hrtime();
var vLoadingData = false;
async function loadData() {
    if (!vLoadingData) {
        vLoadingData = true;
        var vElapsedUsage = process.cpuUsage(vlastCPU);
        var vElapsedTime = secNSec2ms(process.hrtime(vlastTime));
        var vElapsedUsageUser = secNSec2ms(vElapsedUsage.user);
        var vElapsedUsageSystem = secNSec2ms(vElapsedUsage.system);
        vCPUPercent = Number(100 * (vElapsedUsageUser + vElapsedUsageSystem) / vElapsedTime).toFixed(2);
        vlastCPU = process.cpuUsage();
        vlastTime = process.hrtime();
        //Lwets figure out the shift times.
        //Lets set the range to the edges of the current shift.
        await calcShiftTimes(); //Lets calculate the current shift start and end times.
        await loadFLTCycleData(); //Lets load the FLT Cycles to get the Dumped amount.
        if (vFLTChuteDumped.size === 0) {
            await loadFLTCycleData();
        }
        await loadOPCUAData();
        if (vOPCUAChuteSensor.size === 0) {
            await loadOPCUAData();
        }
        await loadMOMSChuteData(); //Lets load the MOM Unloads to get the Taken amount.
        if (vMOMSChuteTaken.size === 0) {
            await loadMOMSChuteData();
        }
        var vAdjustmentResult = await loadFMIChuteAdjustmentData(); //Lets load the Adjustments done in this shift.
        if (!vAdjustmentResult) {
            vAdjustmentResult = await loadFMIChuteAdjustmentData();
        }
        await loadFMIChuteData(); //Lets get the current chute data.
        if (vFMIChuteData.size === 0) {
            await loadFMIChuteData();
        }
        //await loadFLTAPIChuteData();//Lets get the current chute data.
        if ((vFLTChuteDumped.size > 0) && (vOPCUAChuteSensor.size > 0) && (vMOMSChuteTaken.size > 0) && (vAdjustmentResult) && (vFMIChuteData.size > 0)) {
            var vTmpCompleteChuteData = await combineData(); //Now lets join it all together.
            console.log("FMICHUTE:LOADDATA: After Combine[" + vTmpCompleteChuteData.size + "].");
            //console.log("COMBINEDDATA["+vCompleteChuteData.size+"]["+JSON.stringify(Array.from(vCompleteChuteData.entries()))+"].");
            var vTmpCompleteChuteData2 = await finalAdjustmentsAndStoreChuteData(vTmpCompleteChuteData); //If data has changed lets update the chute levels in Minestar Fleet and store in the Chute History Table..
            console.log("FMICHUTE:LOADDATA: After Final Adjust[" + vTmpCompleteChuteData2.size + "].");
            await doChuteHistory(vTmpCompleteChuteData2);
            vCompleteChuteData = new Map(vTmpCompleteChuteData2);
        } else {
            console.log("FMICHUTE:LOADDATA:ERROR Data not complete, skipping calc...");
        }
        vLoadingData = false;
    }
}

var vCompleteChuteDataLast = new Map();
async function doChuteHistory(vData) {
    console.log("FMICHUTE:DOCHUTEHISTORY: Comparing Last Data[" + vCompleteChuteDataLast.size + "]To current Data[" + vData.size + "]...");
    for (const [key, data] of vData) {
        if (vCompleteChuteDataLast.has(key)) {
            if (JSON.stringify(vCompleteChuteDataLast.get(key)) != JSON.stringify(data)) {
                console.log("FMICHUTE:DOCHUTEHISTORY: Found an Update! Lets store it...");
                //console.log("FMICHUTE:DOCHUTEHISTORY: LAST["+JSON.stringify(vCompleteChuteDataLast.get(key))+"]NEW["+JSON.stringify(data)+"].");
                if (vCompleteChuteDataLast.get(key).DUMPED_AMOUNT_TONNES != data.DUMPED_AMOUNT_TONNES) {
                    console.log("FMICHUTE:DOCHUTEHISTORY: Additional dumps [" + vCompleteChuteDataLast.get(key).DUMPED_AMOUNT_TONNES + "]->[" + data.DUMPED_AMOUNT_TONNES + "].");
                }
                if (vCompleteChuteDataLast.get(key).DUMPED_NOSRC_TONNES != data.DUMPED_NOSRC_TONNES) {
                    console.log("FMICHUTE:DOCHUTEHISTORY: Additional no source dumps [" + vCompleteChuteDataLast.get(key).DUMPED_NOSRC_TONNES + "]->[" + data.DUMPED_NOSRC_TONNES + "].");
                }
                if (vCompleteChuteDataLast.get(key).TAKEN_AMOUNT_TONNES != data.TAKEN_AMOUNT_TONNES) {
                    console.log("FMICHUTE:DOCHUTEHISTORY: Additional taken [" + vCompleteChuteDataLast.get(key).TAKEN_AMOUNT_TONNES + "]->[" + data.TAKEN_AMOUNT_TONNES + "].");
                }
                if (vCompleteChuteDataLast.get(key).FMI_ADJUSTMENT_TONNES != data.FMI_ADJUSTMENT_TONNES) {
                    console.log("FMICHUTE:DOCHUTEHISTORY: Additional manual and below 0 adjustments [" + vCompleteChuteDataLast.get(key).FMI_ADJUSTMENT_TONNES + "]->[" + data.FMI_ADJUSTMENT_TONNES + "].");
                }
                if (vCompleteChuteDataLast.get(key).MID_SENSOR_ADJUSTMENT_TONNES != data.MID_SENSOR_ADJUSTMENT_TONNES) {
                    console.log("FMICHUTE:DOCHUTEHISTORY: Additional mid sensor adjustments [" + vCompleteChuteDataLast.get(key).MID_SENSOR_ADJUSTMENT_TONNES + "]->[" + data.MID_SENSOR_ADJUSTMENT_TONNES + "].");
                }
                if (vCompleteChuteDataLast.get(key).CURRENT_LEVEL_TONNES != data.CURRENT_LEVEL_TONNES) {
                    console.log("FMICHUTE:DOCHUTEHISTORY: Current Level Changed [" + vCompleteChuteDataLast.get(key).CURRENT_LEVEL_TONNES + "]->[" + data.CURRENT_LEVEL_TONNES + "].");
                }
                if (vCompleteChuteDataLast.get(key).CALCULATED_LEVEL_TONNES != data.CALCULATED_LEVEL_TONNES) {
                    console.log("FMICHUTE:DOCHUTEHISTORY: Calculated Level Changed [" + vCompleteChuteDataLast.get(key).CALCULATED_LEVEL_TONNES + "]->[" + data.CALCULATED_LEVEL_TONNES + "].");
                }
                await storeChuteHistory(data);
            }
        }
        vCompleteChuteDataLast.set(key, data);
    };
    //vCompleteChuteDataLast = new Map(vData);
}

async function loadFLTCycleData() {
    //var vFLTCycleDataMap=new Map();
    //Now lets load the Cycle data to do the calc for currentcalc
    var vStart = new Date(vCurrentShiftStartTime).toISOString();
    var vEnd = new Date(vCurrentShiftEndTime).toISOString();
    var vURL = 'http://localhost:4990/api/getFLTCycle?startdatetime=' + vStart + '&enddatetime=' + vEnd + '&timeinclusion=end&minduration=9999&isinterim=false&islp=false&istruck=false';
    console.log("FMICHUTE:LOADFLTCYCLEDATA: Loading GETTING FLTCYCLE Rows for Current Calc for Shift Start[" + vStart + "]End[" + vEnd + "]URL[" + vURL + "]...");
    params = {
        method: 'GET',
        url: vURL,
        json: true,
        headers: {
            connection: 'keep-alive',
            authorization: vMRCServerAuth,
            'accept-encoding': 'gzip, deflate',
            'accept-language': 'en-US,en;q=0.9',
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache',
            'Expires': '0',
        },
        timeout: 30000,
    };

    try {
        const vFLTCycle = await axios(params);
        //console.log('MSCOPILOT:FLTCYCLE DATA RESULT:' + JSON.stringify(vFLTCycle.data));
        vFLTChuteDumped = new Map(); //Lets blank it first.
        vFLTCycleData = vFLTCycle.data;
        vFLTCycleData.forEach((datavalue) => {
            if (datavalue.SINK_TYPE === "ORE_PASS") {
                var vChuteName = "" + datavalue.SECONDARY_MACHINE_NAME;
                //console.log("MSDATA:FMICHUTE Found Dump["+vChuteName+"]");
                var vChute = {};
                if (vFLTChuteDumped.has(vChuteName)) {
                    vChute = vFLTChuteDumped.get(vChuteName);
                } else {
                    vChute.DUMPED_AMOUNT_TONNES = 0;
                    vChute.DUMPED_NOSRC_TONNES = 0;
                    vChute.SINK_DESTINATION_NAME = "";
                    vChute.DUMPED_COUNT = 0;
                    vChute.DUMPED_NOSRC_COUNT = 0;
                }
                if (datavalue.PAYLOAD === 0) {
                    datavalue.PAYLOAD = 10;
                }
                if (datavalue.SOURCE_NAME != "" && datavalue.SOURCE_NAME != null) {
                    if (datavalue.MODE === 'CMD') {
                        vChute.DUMPED_AMOUNT_TONNES += (datavalue.PAYLOAD * 0.8) + 0.00;
                    } else {
                        vChute.DUMPED_AMOUNT_TONNES += datavalue.PAYLOAD + 0.00;
                    }
                    vChute.DUMPED_COUNT++;
                } else {
                    if (datavalue.MODE === 'CMD') {
                        vChute.DUMPED_NOSRC_TONNES += (datavalue.PAYLOAD * 0.8) + 0.00;
                    } else {
                        vChute.DUMPED_NOSRC_TONNES += datavalue.PAYLOAD + 0.00;
                    }
                    vChute.DUMPED_NOSRC_COUNT++;
                }
                vChute.SINK_DESTINATION_NAME = "" + datavalue.SINK_DESTINATION_NAME;
                vFLTChuteDumped.set(vChuteName, vChute);
            }
        });
        console.log('FMICHUTE:LOADFLTCYCLEDATA:DATA RECEIVED ROWS[' + vFLTCycleData.length + '].');
    } catch (err) {
        console.log("FMICHUTE:LOADFLTCYCLEDATA:ERRROR:" + err);
    }
    //return vFLTCycleDataMap;
}

async function loadOPCUAData() {
    //var vFLTCycleDataMap=new Map();
    //Now lets load the Cycle data to do the calc for currentcalc
    var vURL = 'http://localhost:4990/api/getOPCUA?type=ChuteSensor';
    console.log("FMICHUTE:LOADOPCUADATA: Loading GETTING OPCUA Chute Sensor Data URL[" + vURL + "]...");
    params = {
        method: 'GET',
        url: vURL,
        json: true,
        headers: {
            connection: 'keep-alive',
            authorization: vMRCServerAuth,
            'accept-encoding': 'gzip, deflate',
            'accept-language': 'en-US,en;q=0.9'
        },
        timeout: 30000,
    };

    try {
        const vOPCUA = await axios(params);
        console.log('FMICHUTE:LOADOPCUADATA: DATA RESULT SIZE[' + vOPCUA.data.length + ']'); //DATA[' + JSON.stringify(vOPCUA.data)+'].');
        vOPCUAChuteSensor = new Map(); //Lets blank it first.
        vOPCUAData = vOPCUA.data;
        //ns1stA35OSS034448LT01A1ST_Worst ns1stA35OSS034448BL01In1BOOL1Value
        vOPCUAData.forEach((datavalue) => {
            //if ( !datavalue.NODEID.includes('In1_BadBOOL1Value')){
            if (!datavalue.NODEID.includes('LT01A1ST_Worst')) {
                var vChute = JSON.parse(JSON.stringify(datavalue));
                if (vChute.NODE_STATUS === "Good") {
                    vChute.NODE_STATUS = "Goody";
                }
                //console.log("FMICHUTE:LOADOPCUADATA: NODEID["+datavalue.NODEID+"]ChuteValueStatus["+datavalue.NODE_STATUS+"]NewStatus["+vChute.NODE_STATUS+"].");
                vOPCUAChuteSensor.set(datavalue.MACHINE_NAME, vChute);
            }

        });
        vOPCUAData.forEach((datavalue) => {
            //if ( datavalue.NODEID.includes('In1_BadBOOL1Value')){
            if (datavalue.NODEID.includes('LT01A1ST_Worst')) {
                if (vOPCUAChuteSensor.has(datavalue.MACHINE_NAME)) {
                    var vChuteSensor = vOPCUAChuteSensor.get(datavalue.MACHINE_NAME);
                    var vNodeStatus = "Bad";
                    if (vChuteSensor.NODE_STATUS === "Goody" && datavalue.NODE_STATUS === "Good" && datavalue.NODE_INPUT_VALUE === "128") {
                        vNodeStatus = "Good";
                    }
                    //console.log("FMICHUTE:LOADOPCUADATA: NODEID["+datavalue.NODEID+"]ChuteValueStatus["+vChuteSensor.NODE_STATUS+"]ChuteStatusStatus["+datavalue.NODE_STATUS+"]ChuteStatusValue["+datavalue.NODE_INPUT_VALUE+"]Results["+vNodeStatus+"].");
                    vChuteSensor.NODE_STATUS = "" + vNodeStatus;
                    vOPCUAChuteSensor.set("" + datavalue.MACHINE_NAME, vChuteSensor);
                }
            }
        });
        console.log('FMICHUTE:LOADOPCUADATA:DATA RECEIVED ROWS[' + vOPCUAChuteSensor.size + '].');
    } catch (err) {
        console.log("FMICHUTE:LOADOPCUADATA:ERRROR:" + err);
    }
    //return vFLTCycleDataMap;
}

async function loadMOMSChuteData() {
    //var vMapChute = new Map();
    //Now lets load the DEZAPP Chute Data
    console.log("FMICHUTE:LOADMOMSCHUTEDATA:Getting MOMSCHUTEDATA Rows...");
    try {
        vMOMSChuteTaken = new Map();
        var request = dbConn2.request();
        //let result = await request.query("SELECT CD.[ID],CD.[ExtractionChuteName],CD.[ExtractionChuteCurrentTonnes],CD.[IsChuteActive],CD.[TransactionType],CD.[Density],CD.[Timestamp],CD.[IsWrittenToOpc] ,CD.[WrittenToOpcAt] FROM [dmlz_mrcapps].dbo.GRACHUTEDATA AS CD INNER JOIN (SELECT MAX(ID) as latest,[ExtractionChuteName] FROM [dmlz_mrcapps].dbo.GRACHUTEDATA GROUP BY [ExtractionChuteName]) AS LD ON CD.ID=LD.latest AND CD.[ExtractionChuteName] = LD.[ExtractionChuteName] ORDER BY CD.ID DESC;");
        //let result = await request.query("SELECT E.[NAME] AS MACHINE_NAME ,(SUM([AdjustmentInTons])*-1) AS TAKEN_AMOUNT_TONNES FROM [Moms].[dbo].[ChuteBalanceAdjustment] CBA LEFT JOIN EQUIPMENT E ON E.[ID]=CBA.[CHUTEID] WHERE E.NAME LIKE '%CH%' AND [Timestamp] > DATEADD(s, " + (vCurrentShiftStartTime/1000 + 9*60*60) + ", '1970-01-01 00:00:00') AND [Timestamp] < DATEADD(s, " + (vCurrentShiftEndTime/1000  + 9*60*60) + ", '1970-01-01 00:00:00') AND SOURCE <> 'Extraction' GROUP BY E.[NAME] ORDER BY E.[NAME] ASC;");
        let result = await request.query("SELECT E.[NAME] AS MACHINE_NAME ,COUNT(E.[ID]) AS TAKEN_COUNT, (SUM([WeightInTons])) AS TAKEN_AMOUNT_TONNES FROM [Moms].[dbo].[Unload] UL LEFT JOIN EQUIPMENT E ON E.[ID]=UL.[CHUTEID] WHERE E.NAME LIKE '%CH%' AND [Timestamp] > DATEADD(s, " + (vCurrentShiftStartTime / 1000 + 9 * 60 * 60) + ", '1970-01-01 00:00:00') AND [Timestamp] < DATEADD(s, " + (vCurrentShiftEndTime / 1000 + 9 * 60 * 60) + ", '1970-01-01 00:00:00') GROUP BY E.[NAME] ORDER BY E.[NAME] ASC;");
        if (result !== null) {
            for (const recordset of result.recordsets) {
                console.log("FMICHUTE:LOADMOMSCHUTEDATA:NEW SUM DATA SIZE[" + recordset.length + "].");
                recordset.forEach((value, index) => {
                    var vValue = {};
                    vValue.TAKEN_AMOUNT_TONNES = value.TAKEN_AMOUNT_TONNES;
                    vValue.TAKEN_COUNT = value.TAKEN_COUNT;
                    //vValue.MIDSENSOR_OK_STATUS = false;
                    //vValue.MIDSENSOR_TRIGGERED_STATUS = false;
                    //vValue.MIDSENSOR_LAST_UPDATE = 0;
                    vMOMSChuteTaken.set(value.MACHINE_NAME, vValue);
                });
            }
            console.log("FMICHUTE:LOADMOMSCHUTEDATA:TOTAL SUM DATA SIZE[" + vMOMSChuteTaken.size + "].");
        }
    } catch (err) {
        console.log("FMICHUTE:LOADMOMSCHUTEDATA:SQL-ERROR:" + err);
    };
    console.log("FMICHUTE:LOADMOMSCHUTEDATA:FINISHED LOADING ALL MOMS CHUTE SUM AND SENSOR DATA"); //["+JSON.stringify(vMAPChute)+"].");
    //return vMapChute;
}

async function loadFMIChuteAdjustmentData() {
    var vResult = false;
    //var vMapChute = new Map();
    //Now lets load the DEZAPP Chute Data
    console.log("FMICHUTE:LOADFMICHUTEADJUSTMENTDATA:Getting FMICHUTEDATA Rows...");
    try {
        vFMIChuteAdjustment = new Map();
        var request = dbConn.request();
        //SELECT [ID] ,[START_TIME] ,[MACHINE_OID] ,[MACHINE_NAME] ,[ADJUSTMENT_AMOUNT_TONNES] ,[ADJUSTMENT_DESCRIPTION] ,[ADJUSTMENT_SOURCE] FROM [gbc_mrcapps].[dbo].[FMICHUTE_ADJUSTMENT] 
        let result = await request.query("SELECT [MACHINE_NAME],[ADJUSTMENT_TYPE],SUM([ADJUSTMENT_AMOUNT_TONNES]) AS FMI_ADJUSTMENT_TONNES FROM [gbc_mrcapps].[dbo].[FMICHUTE_ADJUSTMENT] WHERE  [START_TIME] > DATEADD(s, " + (vCurrentShiftStartTime / 1000 + 9 * 60 * 60) + ", '1970-01-01 00:00:00') AND [START_TIME] < DATEADD(s, " + (vCurrentShiftEndTime / 1000 + 9 * 60 * 60) + ", '1970-01-01 00:00:00') GROUP BY [MACHINE_NAME],[ADJUSTMENT_TYPE] ORDER BY [MACHINE_NAME] ASC;");
        if (result !== null) {
            for (const recordset of result.recordsets) {
                console.log("FMICHUTE:LOADFMICHUTEADJUSTMENTDATA:NEW SUM DATA SIZE[" + recordset.length + "].");
                recordset.forEach((value, index) => {
                    var vValue = {};
                    if (vFMIChuteAdjustment.has(value.MACHINE_NAME)) {
                        vValue = vFMIChuteAdjustment.get(value.MACHINE_NAME);
                        if (value.ADJUSTMENT_TYPE === 'MID_SENSOR') {
                            vValue.MID_SENSOR_ADJUSTMENT_TONNES += value.FMI_ADJUSTMENT_TONNES;
                        } else {
                            vValue.FMI_ADJUSTMENT_TONNES += value.FMI_ADJUSTMENT_TONNES;
                        }
                    } else {
                        if (value.ADJUSTMENT_TYPE === 'MID_SENSOR') {
                            vValue.MID_SENSOR_ADJUSTMENT_TONNES = value.FMI_ADJUSTMENT_TONNES;
                            vValue.FMI_ADJUSTMENT_TONNES = 0;
                        } else {
                            vValue.FMI_ADJUSTMENT_TONNES = value.FMI_ADJUSTMENT_TONNES;
                            vValue.MID_SENSOR_ADJUSTMENT_TONNES = 0;
                        }
                    }
                    vFMIChuteAdjustment.set(value.MACHINE_NAME, vValue);
                });
            }
            console.log("FMICHUTE:LOADFMICHUTEADJUSTMENTDATA:TOTAL SUM DATA SIZE[" + vFMIChuteAdjustment.size + "].");
            vResult = true;
        }
    } catch (err) {
        console.log("FMICHUTE:LOADFMICHUTEADJUSTMENTDATA:SQL-ERROR:" + err);
    };
    console.log("FMICHUTE:LOADFMICHUTEADJUSTMENTDATA:FINISHED LOADING ALL FMI ADJUSTMENTS DATA"); //["+JSON.stringify(vMAPChute)+"].");
    return vResult;
}

async function loadFLTAPIChuteData() {
    //var vReturnMap=new Map();
    try {
        console.log("FMICHUTE:LOADFLTAPICHUTEDATA:Requesting active chutes...");
        const params = {
            method: 'GET',
            url: 'http://' + vFLTServer + ':1100/underground/api/chutes?active=true',
            json: true,
            headers: {
                Authorization: vFLTServerAuth,
            },
            timeout: 30000,
        };

        const data = await axios(params);
        //vFMIChuteData=data.data;
        //console.log('FMICHUTE:loadFLTAPIChuteData DATA Loaded[' + JSON.stringify(data.data));
        for (const chute of data.data) {
            vFMIChuteData.set(chute.name, chute);
            //await storeChute(chute);
        }
        console.log('FMICHUTE:LOADFLTAPICHUTEDATA: FLT Chute Data Loaded[' + vFMIChuteData.size + "].");
    } catch (err) {
        console.error("FMICHUTE:LOADFLTAPICHUTEDATA:LOAD INITIAL DATA ERROR:" + err); // should contain code (exit code) and signal (that caused the termination).
    }
    console.log("FMICHUTE:LOADFLTAPICHUTEDATA:FINISHED PROCESSING ALL CHUTES.");
    //return vReturnMap;
}

//[OID] [bigint] NOT NULL,[ACTIVE] [bit] NULL, [MACHINE_NAME] [nvarchar](64) NULL, [OREPASS_NAME] [nvarchar](64) NULL, [LOADING_POINT_NAME] [nvarchar](64) NULL, [TOTAL_CAPACITY_TONNES] [float] NULL, [MIDSENSOR_TONNES] [float] NULL, [CAPACITY_LIMIT_TONNES] [float] NULL, [INITIAL_LEVEL_TONNES] [float] NULL, [CURRENT_LEVEL_TONNES] [float] NULL, [TAKEN_AMOUNT_TONNES] [float] NULL, [DUMPED_AMOUNT_TONNES] [float] NULL
async function loadFMIChuteData() {
    //var vMapChute = new Map();
    //Now lets load the DEZAPP Chute Data
    console.log("FMICHUTE:LOADFMICHUTEDATA:Getting FMICHUTEDATA Rows...");
    try {
        vFMIChuteData = new Map();
        var request = dbConn.request();
        //SELECT [ID] ,[START_TIME] ,[MACHINE_OID] ,[MACHINE_NAME] ,[ADJUSTMENT_AMOUNT_TONNES] ,[ADJUSTMENT_DESCRIPTION] ,[ADJUSTMENT_SOURCE] FROM [gbc_mrcapps].[dbo].[FMICHUTE_ADJUSTMENT]
        let result = await request.query("SELECT * FROM [gbc_mrcapps].[dbo].[FMICHUTE] ORDER BY [MACHINE_NAME] ASC");
        if (result !== null) {
            for (const recordset of result.recordsets) {
                console.log("FMICHUTE:LOADFMICHUTEDATA:NEW SUM DATA SIZE[" + recordset.length + "].");
                for (const value of recordset) {
                    //for ( recordset.forEach(async (value,index) => {
                    if (parseInt(value.SHIFT_START_TIMESTAMP) != vCurrentShiftStartTime) {
                        if (vCompleteChuteDataLast.has(value.MACHINE_NAME)) {
                            vChute = vCompleteChuteDataLast.get(value.MACHINE_NAME);
                            value.INITIAL_LEVEL_TONNES = vChute.CURRENT_LEVEL_TONNES;
                            value.SHIFT_START_TIMESTAMP = vCurrentShiftStartTime;
                            //value.TAKEN_AMOUNT_TONNES = 0;
                            //value.DUMPED_AMOUNT_TONNES = 0;
                            //Lets calculate the Initial Amount.
                            await storeFMIChute(value);
                        }
                    }
                    vFMIChuteData.set(value.MACHINE_NAME, value);
                };
            }
            console.log("FMICHUTE:LOADFMICHUTEDATA:TOTAL SUM DATA SIZE[" + vFMIChuteData.size + "].");
        }
    } catch (err) {
        console.log("FMICHUTE:LOADFMICHUTEDATA:SQL-ERROR:" + err);
    };
    console.log("FMICHUTE:LOADFMICHUTEDATA:FINISHED LOADING ALL FMI ADJUSTMENTS DATA"); //["+JSON.stringify(vMAPChute)+"].");
    //return vMapChute;
}

async function finalAdjustmentsAndStoreChuteData(vChuteData) {
    var vReturnData = new Map();
    //EXAMPLE DATA:{ "active": true, "capacity_limit_tonnes": 0,  "current_level_tonnes": 0, "dumped_amount_tonnes": 0, "flow_rate": 0, "hazard_status": "string", "hazard_status_oid": 0, "inital_level_tonnes": 0, "name": "string", "oid": 0, "taken_amount_tonnes": 0, "total_capacity_tonnes": 0 }
    //Now lets check if its different
    var vCount = 0;
    for (const [key, chute] of vChuteData) {
        //vChuteData.forEach(async (chute,key) => {
        try {
            vCount++;
            console.log('FMICHUTE:UPDATE CURRENT LEVEL TEST FOR CHUTE:[' + vCount + ']MACHINE[' + key + ']CHUTE[' + JSON.stringify(chute) + '].');
            //CaclCurent uses this(vLP.INITIAL_LEVEL_TONNES + vLP.DUMPED_AMOUNT_TONNES - vLP.TAKEN_AMOUNT_TONNES + vLP.FMI_ADJUSTMENT_TONNES + 0.00)*100/100;
            var vCalcLevel = calcCurrentLevel(chute);
            //Lets make an auto adjustment to move it up to 0 if its below.
            if (vCalcLevel < 0) {
                var vAdjustment = {};
                vAdjustment.START_TIME = new Date();
                vAdjustment.MACHINE_OID = parseInt(chute.MACHINE_OID);
                vAdjustment.MACHINE_NAME = "" + chute.MACHINE_NAME;
                vAdjustment.ADJUSTMENT_AMOUNT_TONNES = -vCalcLevel;
                vAdjustment.ADJUSTMENT_DESCRIPTION = "Below Zero";
                vAdjustment.ADJUSTMENT_SOURCE = "FMICHUTE";
                vAdjustment.ADJUSTMENT_TYPE = "SYSTEM";
                var vResult = await storeFMIChuteAdjustment(vAdjustment);
                console.log("FMICHUTE:finalAdjustmentsAndStoreChuteData:[" + vCount + "] Stored Adjustment[" + vResult + "].");
                vCalcLevel = 0;
				//Lets also set the Sensor adjustments back to 0 since empty.
				chute.MID_SENSOR_ADJUSTMENT_TONNES=0;
            }
			//now lets do the mid level sensor one.
            //console.log("FMICHUTE:finalAdjustmentsAndStoreChuteData: UseSensor["+chute.USE_MID_SENSOR+"]SENSOR_STATUS["+ ["+ chute.USE_MID_VALUE+","+vCalcLevel+","+chute.MIDSENSOR_TONNES+"].");
            /*if ( chute.USE_MID_SENSOR && chute.MID_SENSOR_STATUS) {
			//console.log("FMICHUTE:finalAdjustmentsAndStoreChuteData: Using Sensor ["+ chute.USE_MID_VALUE+","+vCalcLevel+","+chute.MIDSENSOR_TONNES+"].");
			if ( chute.MID_SENSOR_VALUE && vCalcLevel < chute.MIDSENSOR_TONNES ){
				var vAdjustment={};
                               	vAdjustment.START_TIME=new Date();
                               	vAdjustment.MACHINE_OID=chute.MACHINE_OID;
                               	vAdjustment.MACHINE_NAME=""+chute.MACHINE_NAME;
                               	vAdjustment.ADJUSTMENT_AMOUNT_TONNES = chute.MIDSENSOR_TONNES - vCalcLevel;
                               	vAdjustment.ADJUSTMENT_DESCRIPTION = "Moving Level up to Sensor Level";
                               	vAdjustment.ADJUSTMENT_SOURCE = "FMICHUTE";
                               	vAdjustment.ADJUSTMENT_TYPE = "MID_SENSOR";
                               	var vResult = await storeFMIChuteAdjustment(vAdjustment);
                               	vCalcLevel=chute.MIDSENSOR_TONNES;
			}else if ( !chute.MID_SENSOR_VALUE && vCalcLevel > chute.MIDSENSOR_TONNES ){
				var vAdjustment={};
                                vAdjustment.START_TIME=new Date();
                                vAdjustment.MACHINE_OID=chute.MACHINE_OID;
                                vAdjustment.MACHINE_NAME=""+chute.MACHINE_NAME;
                                vAdjustment.ADJUSTMENT_AMOUNT_TONNES = chute.MIDSENSOR_TONNES - vCalcLevel;
                                vAdjustment.ADJUSTMENT_DESCRIPTION = "Moving Level down to Sensor Level";
                                vAdjustment.ADJUSTMENT_SOURCE = "FMICHUTE";
                                vAdjustment.ADJUSTMENT_TYPE = "MID_SENSOR";
                                var vResult = await storeFMIChuteAdjustment(vAdjustment);
                                vCalcLevel=chute.MIDSENSOR_TONNES;
			}
		}*/

            var vSensorLevelAdjustment = await calcSensorLevel(chute, vCalcLevel);

            if (chute.CURRENT_LEVEL_TONNES != vCalcLevel || chute.MID_SENSOR_ADJUSTMENT_TONNES != vSensorLevelAdjustment) {
            //if (chute.CURRENT_LEVEL_TONNES != vCalcLevel || vSensorLevelAdjustment != 0) {
                console.log("FMICHUTE:finalAdjustmentsAndStoreChuteData:[" + vCount + "] Current[" + chute.CURRENT_LEVEL_TONNES + "]<>NewCurrent[" + vCalcLevel + "]||MID[" + chute.MID_SENSOR_ADJUSTMENT_TONNES + "]<>NEWMID[" + vSensorLevel + "].");
                chute.CURRENT_LEVEL_TONNES = vCalcLevel + 0.00;
                chute.MID_SENSOR_ADJUSTMENT_TONNES = vSensorLevelAdjustment + 0.00;
                var vResult = await storeFMIChute(JSON.parse(JSON.stringify(chute)));
                console.log("FMICHUTE:finalAdjustmentsAndStoreChuteData:[" + vCount + "] Stored FMIChute[" + vResult + "].");
            }
        } catch (err) {
            console.log("FMICHUTE:finalAdjustmentsAndStoreChuteData:[" + vCount + "]Error " + err);
        }
        console.log("FMICHUTE:finalAdjustmentsAndStoreChuteData:[" + vCount + "] Storing[" + chute.MACHINE_NAME + "].");
        vReturnData.set(key, (JSON.parse(JSON.stringify(chute))));
        //});
    }
    return vReturnData;
}

//Stores the event source data into the SQL Datbase.
async function storeChuteHistory(vData) {
    //vCurrentMachine.set(vData.name,vData);
    try {
        console.log('FMICHUTE:STORECHUTEHISTORY:Storing Chute History...'); //[' + JSON.stringify(vData) + ']...');
        var request = dbConn.request();
        let result = await request
            .input("vstart_time", sql.DateTimeOffset(3), new Date(new Date().getTime() - (9 * 60 * 60 * 1000))) //vData.START_TIME )
            .input("vmachine_oid", sql.BigInt, vData.OID)
            .input("vmachine_name", sql.NVarChar(64), vData.MACHINE_NAME)
            .input("vinitial_level_tonnes", sql.Float, vData.INITIAL_LEVEL_TONNES)
            .input("vcurrent_level_tonnes", sql.Float, vData.CURRENT_LEVEL_TONNES)
            .input("vtotal_capacity_tonnes", sql.Float, vData.TOTAL_CAPACITY_TONNES)
            .input("vflow_rate", sql.Float, vData.FLOW_RATE)
            .input("vcapacity_limit_tonnes", sql.Float, vData.CAPACITY_LIMIT_TONNES)
            .input("vfltcycle_taken_tonnes", sql.Float, vData.TAKEN_AMOUNT_TONNES)
            .input("vfltcycle_dumped_tonnes", sql.Float, vData.DUMPED_AMOUNT_TONNES)
            .input("vfltcycle_nosrc_taken_tonnes", sql.Float, vData.FLTCYCLE_NOSRC_TAKEN__TONNES)
            .input("vfltcycle_nosrc_dumped_tonnes", sql.Float, vData.DUMPED_NOSRC_TONNES)
            .input("vmidsensor_tonnes", sql.Float, vData.MIDSENSOR_TONNES)
            .input("vsink_destination_name", sql.NVarChar(64), vData.SINK_DESTINATION_NAME)
            .input("vfmi_adjustment_tonnes", sql.Float, vData.FMI_ADJUSTMENT_TONNES)
            .input("vcalculated_level_tonnes", sql.Float, vData.CALCULATED_LEVEL_TONNES)
            .input("vmid_sensor_adjustment_tonnes", sql.Float, vData.MID_SENSOR_ADJUSTMENT_TONNES)
            .query("EXECUTE mrcFMIChuteHistoryInsert @vstart_time, @vmachine_oid, @vmachine_name, @vinitial_level_tonnes, @vcurrent_level_tonnes, @vtotal_capacity_tonnes, @vflow_rate, @vcapacity_limit_tonnes, @vfltcycle_taken_tonnes, @vfltcycle_dumped_tonnes, @vfltcycle_nosrc_taken_tonnes, @vfltcycle_nosrc_dumped_tonnes, @vmidsensor_tonnes, @vsink_destination_name, @vfmi_adjustment_tonnes, @vcalculated_level_tonnes, @vmid_sensor_adjustment_tonnes");
        if (result !== null) {
            console.log('FMICHUTE:STORECHUTE:CHUTE[' + vData.MACHINE_NAME + '] SAVED RESULT:' + result.rowsAffected);
            vDataStoreCount++;
        } else {
            console.log('FMICHUTE:STORECHUTE:CHUTE[' + vData.MACHINE_NAME + '] Failed...');
            vDataStoreFailCount++;
        }
    } catch (err) {
        console.log('FMICHUTE:STORECHUTE:SQL ERROR:' + err + ' CHUTE[' + JSON.stringify(vData) + '].');
        vDataStoreFailCount++
    }
}

//Stores the event source data into the SQL Datbase.
async function storeFMIChuteAdjustment(vData) {
    //vCurrentMachine.set(vData.name,vData);
    try {
        console.log('FMICHUTE:STOREFMICHUTEADJUSTMENT:Storing Chute Adjustment...'); //[' + JSON.stringify(vData) + ']...');
        //if ( !vData.current_level_tonnes ) {
        //        console.log('FMICHUTE:STOREFMMICHUTEADJUSTMENT:Error Chute Data not Correct Current[' + vData.current_level_tonnes + ']...');
        //        vData.current_level_tonnes=0;
        //}
        //if ( !vData.inital_level_tonnes ) {
        //        console.log('FMICHUTE:STOREFMICHUTEADJUSTMENT:Error Chute Data not Correct Initial[' + vData.inital_level_tonnes + ']...');
        //        vData.inital_level_tonnes=0;
        //}
        // CHUTE[{"START_TIME":"2024-10-18T00:19:14.932Z","MACHINE_OID":448134823,"MACHINE_NAME":"4533CH533","ADJUSTMENT_AMOUNT_TONNES":-337.78999999999996,"ADJUSTMENT_DESCRIPTION":"Chute Level Set Manually","ADJUSTMENT_SOURCE":"API-admin"}]
        var request = dbConn.request();
        let result = await request
            .input("vstart_time", sql.DateTimeOffset(3), vData.START_TIME)
            .input("vmachine_oid", sql.BigInt, vData.MACHINE_OID)
            .input("vmachine_name", sql.NVarChar(64), vData.MACHINE_NAME)
            .input("vadjustment_amount_tonnes", sql.Float, vData.ADJUSTMENT_AMOUNT_TONNES)
            .input("vadjustment_type", sql.NVarChar(64), vData.ADJUSTMENT_TYPE)
            .input("vadjustment_source", sql.NVarChar(64), vData.ADJUSTMENT_SOURCE)
            .input("vadjustment_description", sql.NVarChar(64), vData.ADJUSTMENT_DESCRIPTION)
            .query("EXECUTE mrcFMIChuteAdjustmentInsert @vstart_time, @vmachine_oid, @vmachine_name,@vadjustment_amount_tonnes, @vadjustment_type, @vadjustment_source, @vadjustment_description");
        if (result !== null) {
            console.log('FMICHUTE:STOREFMICHUTEADJUSTMENT:CHUTE[' + vData.MACHINE_NAME + '] SAVED RESULT:' + result.rowsAffected);
            vDataStoreCount++;
        } else {
            console.log('FMICHUTE:STOREFMICHUTEADJUSTMENT:CHUTE[' + vData.MACHINE_NAME + '] Failed...');
            vDataStoreFailCount++;
            return false;
        }
    } catch (err) {
        console.log('FMICHUTE:STOREFMICHUTEADJUSTMENT:SQL ERROR:' + err + ' CHUTE[' + JSON.stringify(vData) + '].');
        vDataStoreFailCount++;
        return false;
    }
    return true;
}

//[OID] [bigint] NOT NULL,[ACTIVE] [bit] NULL, [MACHINE_NAME] [nvarchar](64) NULL, [OREPASS_NAME] [nvarchar](64) NULL, [LOADING_POINT_NAME] [nvarchar](64) NULL, [TOTAL_CAPACITY_TONNES] [float] NULL, [MIDSENSOR_TONNES] [float] NULL, [CAPACITY_LIMIT_TONNES] [float] NULL, [INITIAL_LEVEL_TONNES] [float] NULL, [CURRENT_LEVEL_TONNES] [float] NULL, [TAKEN_AMOUNT_TONNES] [float] NULL, [DUMPED_AMOUNT_TONNES] [float] NULL
//Stores the event source data into the SQL Datbase.
async function storeFMIChute(vData) {
    //vCurrentMachine.set(vData.name,vData);
    try {
        console.log('FMICHUTE:STOREFMICHUTE:Storing Chute Data...');
        var request = dbConn.request();
        let result = await request
            .input("vmachine_name", sql.NVarChar(64), vData.MACHINE_NAME)
            .input("vinitial_level_tonnes", sql.Float, vData.INITIAL_LEVEL_TONNES)
            .input("vcurrent_level_tonnes", sql.Float, vData.CURRENT_LEVEL_TONNES)
            .input("vtaken_amount_tonnes", sql.Float, vData.TAKEN_AMOUNT_TONNES)
            .input("vdumped_amount_tonnes", sql.Float, vData.DUMPED_AMOUNT_TONNES)
            .input("vshift_start_timestamp", sql.BigInt, vData.SHIFT_START_TIMESTAMP) //vCurrentShiftStartTime)
            .query("EXECUTE mrcFMICHUTEUpdate @vmachine_name, @vinitial_level_tonnes, @vcurrent_level_tonnes, @vtaken_amount_tonnes, @vdumped_amount_tonnes, @vshift_start_timestamp");
        if (result !== null) {
            console.log('FMICHUTE:STOREFMICHUTE:CHUTE[' + vData.MACHINE_NAME + '] SAVED RESULT:' + result.rowsAffected);
            vDataStoreCount++;
        } else {
            console.log('FMICHUTE:STOREFMICHUTE:CHUTE[' + vData.MACHINE_NAME + '] Failed...');
            vDataStoreFailCount++;
            return false;
        }
    } catch (err) {
        console.log('FMICHUTE:STOREFMICHUTE:SQL ERROR:' + err + ' CHUTE[' + JSON.stringify(vData) + '].');
        vDataStoreFailCount++;
        return false;
    }
    return true;
}

async function storeFMIChuteSettings(vData) {
    //vCurrentMachine.set(vData.name,vData);
    try {
        console.log('FMICHUTE:STOREFMICHUTESETTINGS:Storing Chute Settings Data...');
        var request = dbConn.request();
        let result = await request
            .input("vmachine_name", sql.NVarChar(64), vData.MACHINE_NAME)
            .input("vuse_mid_sensor", sql.Bit, vData.USE_MID_SENSOR)
            .query("UPDATE FMICHUTE SET [USE_MID_SENSOR] = @vuse_mid_sensor WHERE [MACHINE_NAME]=@vmachine_name");
        if (result !== null) {
            console.log('FMICHUTE:STOREFMICHUTESETTINGS:CHUTE[' + vData.MACHINE_NAME + '] SAVED RESULT:' + result.rowsAffected);
            vDataStoreCount++;
        } else {
            console.log('FMICHUTE:STOREFMICHUTESETTINGS:CHUTE[' + vData.MACHINE_NAME + '] Failed...');
            vDataStoreFailCount++;
        }
    } catch (err) {
        console.log('FMICHUTE:STOREFMICHUTESETTINGS:SQL ERROR:' + err + ' CHUTE[' + JSON.stringify(vData) + '].');
        vDataStoreFailCount++
    }
}

//Setup the database connection pool.
var dbConn = new sql.ConnectionPool(dbConfig);
var dbConn2 = new sql.ConnectionPool(dbConfig2);
startDBConnect();
//setInterval(doSync,vDoSyncInterval);

//Now lets setup the WEB API ENDPOINTS
var app = express();
app.use((req, res, next) => {
    res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    res.header('Access-Control-Allow-Credentials', true);
    return next();
});

function secNSec2ms(secNSec) {
    if (Array.isArray(secNSec)) {
        return secNSec[0] * 1000 + secNSec[1] / 1000000;
    }
    return secNSec / 1000;
}

var vLastIDFLTChuteHistory = 0;
var vLoadingHistoricalData = false;
async function loadHistoryData() {
    if (!vLoadingHistoricalData) {
        vLoadingHistoricalData = true;
        //Load the FMICHUTE table.
        console.log("FMICHUTE:LOADHISTORICALDATA: GETTING FMICHUTE Rows...");
        try {
            vDataInputRequestCount++;
            var request = dbConn.request();
            let result = await request.query("SELECT * FROM FMICHUTE_HISTORY WHERE ID > " + vLastIDFLTChuteHistory + " ORDER BY ID ASC;"); //AND UPDATE_SOURCE='MOMS' ORDER BY ID ASC;");
            if (result !== null) {
                for (const recordset of result.recordsets) {
                    console.log("FMICHUTE:LOADHISTORICALDATA: DATA SIZE[" + recordset.length + "].");
                    recordset.forEach((value, index) => {
                        vDataInputCount++;
                        //value.MACHINE_NAME=""+value.NAME;
                        vMAPFMIChuteHistoricalData.set(value.ID, value);
                        if (value.ID > vLastIDFLTChuteHistory) {
                            vLastIDFLTChuteHistory = value.ID;
                        }
                    });
                }
                console.log("FMICHUTE:LOADHISTORICALDATA: NEW TOTAL DATA SIZE[" + vMAPFMIChuteHistoricalData.size + "]CURRENT[" + vMAPFMIChuteHistoricalData.size + "].");
            }
        } catch (err) {
            console.log("FMICHUTE:LOADHISTORICALDATA: CURRENT SQL-ERROR:" + err);
        }
        vLoadingHistoricalData = false;
    }
}

async function combineData() { //vFLTChuteDumped,vMOMSChuteTaken,vFMIChuteAdjustment,vFMIChuteData){
    console.log("FMICHUTE:COMBINEDATA: Combining ChuteOPCUA[" + vOPCUAChuteSensor.size + "]ChuteDumped[" + vFLTChuteDumped.size + "]ChuteTaken[" + vMOMSChuteTaken.size + "]FMIAdjust[" + vFMIChuteAdjustment.size + "]FMIChuteData[" + vFMIChuteData.size + "].");
    var vReturnMap = new Map();
    //Setup intitial values and set initial level.
    vFMIChuteData.forEach((value, index) => {
        value.TAKEN_AMOUNT_TONNES = 0;
        value.TAKEN_COUNT = 0;
        value.DUMPED_AMOUNT_TONNES = 0;
        value.DUMPED_COUNT = 0;
        value.DUMPED_NOSRC_TONNES = 0;
        value.FMI_ADJUSTMENT_TONNES = 0;
        value.MID_SENSOR_STATUS = false;
        value.MID_SENSOR_VALUE = false;
        value.MID_SENSOR_TIMESTAMP = "";
        value.MIDSENSOR_TONNES = parseInt(value.MIDSENSOR_TONNES) + 0.00
        value.MID_SENSOR_ADJUSTMENT_TONNES = 0;
        vReturnMap.set(index, value);
    });

    vOPCUAChuteSensor.forEach((datavalue, index, array) => {
        if (vReturnMap.has(index)) {
            var vChute = vReturnMap.get(index);
            console.log("FMICHUTE:COMBINEDATA: MACHINE_NAME[" + vChute.MACHINE_NAME + "]NODE_STATUS[" + datavalue.NODE_STATUS + "]");
            vChute.MID_SENSOR_STATUS = (datavalue.NODE_STATUS === 'Good');
            vChute.MID_SENSOR_VALUE = (datavalue.NODE_INPUT_VALUE === 'True');
            vChute.MID_SENSOR_TIMESTAMP = "" + datavalue.START_TIME;
            vReturnMap.set(index, vChute);
        } else {
            console.log("FMICHUTE:COMBINEDATA: INDEX[" + index + "]Not found in ChuteData...");
        }
    });

    vFMIChuteAdjustment.forEach((datavalue, index, array) => {
        if (vReturnMap.has(index)) {
            var vChute = vReturnMap.get(index);
            vChute.FMI_ADJUSTMENT_TONNES = datavalue.FMI_ADJUSTMENT_TONNES + 0.00;
            vChute.MID_SENSOR_ADJUSTMENT_TONNES = datavalue.MID_SENSOR_ADJUSTMENT_TONNES + 0.00;
            //if ( vChute.USE_MID_SENSOR) {
            //	vChute.FMI_ADJUSTMENT_TONNES += datavalue.MID_SENSOR_ADJUSTMENT_TONNES;
            //}
            //vChute.MIDSENSOR_OK_STATUS = datavalue.MIDSENSOR_OK_STATUS;
            //vChute.MIDSENSOR_TRIGGERED_STATUS = datavalue.MIDSENSOR_TRIGGERED_STATUS;
            //vChute.MIDSENSOR_LAST_UPDATE = datavalue.MIDSENSOR_LAST_UPDATE;
            vReturnMap.set(index, vChute);
        }
    });
    //console.log("FMICHUTE:LOADDATA: Filtering FLTCycles for Shift Start["+ vCurrentShiftStartTime + "]End["+vCurrentShiftEndTime+"]...");
    //Lets do orepass level calc based on current shift.
    vFLTChuteDumped.forEach((datavalue, index, array) => {
        if (vReturnMap.has(index)) {
            var vChute = vReturnMap.get(index);
            vChute.DUMPED_AMOUNT_TONNES = datavalue.DUMPED_AMOUNT_TONNES + 0.00;
            vChute.DUMPED_COUNT = datavalue.DUMPED_COUNT;
            vChute.DUMPED_NOSRC_TONNES = datavalue.DUMPED_NOSRC_TONNES + 0.00;
            vChute.DUMPED_NOSRC_COUNT = datavalue.DUMPED_NOSRC_COUNT + 0.00;
            vReturnMap.set(index, vChute);
        }
    });
    //console.log("FMICHUTE:LOADDATA: Filtering FLTCycles for Shift Start["+ vCurrentShiftStartTime + "]End["+vCurrentShiftEndTime+"]...");
    vMOMSChuteTaken.forEach((datavalue, index, array) => {
        if (vReturnMap.has(index)) {
            var vChute = vReturnMap.get(index);
            vChute.TAKEN_AMOUNT_TONNES = datavalue.TAKEN_AMOUNT_TONNES + 0.00;
            vChute.TAKEN_COUNT = datavalue.TAKEN_COUNT;
            //vChute.MIDSENSOR_OK_STATUS = datavalue.MIDSENSOR_OK_STATUS;
            //vChute.MIDSENSOR_TRIGGERED_STATUS = datavalue.MIDSENSOR_TRIGGERED_STATUS;
            //vChute.MIDSENSOR_LAST_UPDATE = datavalue.MIDSENSOR_LAST_UPDATE;
            vReturnMap.set(index, vChute);
        }
    });

    vReturnMap.forEach((value, index) => {
        if (!value.INITIAL_LEVEL_TONNES) {
            value.INITIAL_LEVEL_TONNES = 0;
        }
        if (!value.DUMPED_AMOUNT_TONNES) {
            value.DUMPED_AMOUNT_TONNES = 0;
        }
        if (!value.TAKEN_AMOUNT_TONNES) {
            value.TAKEN_AMOUNT_TONNES = 0;
        }
        if (!value.FMI_ADJUSTMENT_TONNES) {
            value.FMI_ADJUSTMENT_TONNES = 0;
        }
        value.CALCULATED_LEVEL_TONNES = calcCalcLevel(value);
        vReturnMap.set(index, value);
    });
    console.log("FMICHUTE:COMBINEDATA: Return Data Size[" + vReturnMap.size + "].");
    return new Map(vReturnMap);
}

var vCurrentShiftStartTime = 0;
var vCurrentShiftEndTime = 0;

async function calcShiftTimes() {
    //Lwets figure out the shift times.
    //Lets set the range to the edges of the current shift.
    var vDate = new Date();
    vDate.setHours(5);
    vDate.setMinutes(0);
    vDate.setSeconds(0);
    vDate.setMilliseconds(0);
    var vStartDayShift = vDate.getTime();
    vDate.setHours(17);
    var vEndDayShift = vDate.getTime();
    var vCurrentTimeStamp = (new Date()).getTime();
    if (vCurrentTimeStamp < vStartDayShift) {
        vCurrentShiftStartTime = vEndDayShift - (3600 * 24 * 1000);
        vCurrentShiftEndTime = vStartDayShift;
    } else if (vCurrentTimeStamp < vEndDayShift) {
        vCurrentShiftStartTime = vStartDayShift;
        vCurrentShiftEndTime = vEndDayShift;
    } else {
        vCurrentShiftStartTime = vEndDayShift;
        vCurrentShiftEndTime = vStartDayShift + (3600 * 24 * 1000);
    }
    console.log("FMICHUTE:CALCSHIFTTIMES: Shift Start[" + vCurrentShiftStartTime + "]End[" + vCurrentShiftEndTime + "].");
}

function calcCalcLevel(vLP) {
    var vTemp = vLP.INITIAL_LEVEL_TONNES + vLP.DUMPED_AMOUNT_TONNES - vLP.TAKEN_AMOUNT_TONNES + 0.00;
    return parseInt(vTemp * 100) / 100 + 0.00;
}

function calcCurrentLevel(vLP) {
    var vTemp = vLP.INITIAL_LEVEL_TONNES + vLP.DUMPED_AMOUNT_TONNES - vLP.TAKEN_AMOUNT_TONNES + vLP.FMI_ADJUSTMENT_TONNES + 0.00;
    //if ( vLP.USE_MID_SENSOR) {
    //	vTemp += vLP.MID_SENSOR_ADJUSTMENT_TONNES + 0.00;
    //}
    vTemp = parseInt(vTemp * 100) / 100 + 0.00;
    console.log("FMICHUTE:CalcCurrentLevel: INITIAL[" + vLP.INITIAL_LEVEL_TONNES + "]DUMPED[" + vLP.DUMPED_AMOUNT_TONNES + "]TAKEN[" + vLP.TAKEN_AMOUNT_TONNES + "]FMIADJUST[" + vLP.FMI_ADJUSTMENT_TONNES + "]RESULT[" + vTemp + "].");
    return vTemp;
}

function calcCurrentSensorLevel(vLP) {
    var vTemp = vLP.INITIAL_LEVEL_TONNES + vLP.DUMPED_AMOUNT_TONNES - vLP.TAKEN_AMOUNT_TONNES + vLP.MID_SENSOR_ADJUSTMENT_TONNES + 0.00;
    //if ( vLP.USE_MID_SENSOR) {
    //  vTemp += vLP.MID_SENSOR_ADJUSTMENT_TONNES + 0.00;
    //}
    vTemp = parseInt(vTemp * 100) / 100 + 0.00;
    console.log("FMICHUTE:CalcCurrentSensorLevel: INITIAL[" + vLP.INITIAL_LEVEL_TONNES + "]DUMPED[" + vLP.DUMPED_AMOUNT_TONNES + "]TAKEN[" + vLP.TAKEN_AMOUNT_TONNES + "]ADJUST[" + vLP.FMI_ADJUSTMENT_TONNES + "]RESULT[" + vTemp + "].");
    return vTemp;
}

async function calcSensorAdjustment(chute, vCalcLevel) {
    var vTest = vCalcLevel;
    if (chute.MID_SENSOR_STATUS) {
        //console.log("FMICHUTE:finalAdjustmentsAndStoreChuteData: Using Sensor ["+ chute.USE_MID_VALUE+","+vCalcLevel+","+chute.MIDSENSOR_TONNES+"].");
        if (chute.MID_SENSOR_VALUE && (vTest < chute.MIDSENSOR_TONNES)) { // && ( vTest >= 0 )){
            var vAdjustment = {};
            vAdjustment.START_TIME = new Date();
            vAdjustment.MACHINE_OID = chute.MACHINE_OID;
            vAdjustment.MACHINE_NAME = "" + chute.MACHINE_NAME;
            vAdjustment.ADJUSTMENT_AMOUNT_TONNES = chute.MIDSENSOR_TONNES - vTest;
            vAdjustment.ADJUSTMENT_DESCRIPTION = "Moving Level up to Sensor Level";
            vAdjustment.ADJUSTMENT_SOURCE = "SENSORCHUTE";
            vAdjustment.ADJUSTMENT_TYPE = "MID_SENSOR";
            var vResult = await storeFMIChuteAdjustment(vAdjustment);
            return chute.MID_SENSOR_ADJUSTMENT_TONNES + vAdjustment.ADJUSTMENT_AMOUNT_TONNES;
            //return vAdjustment.ADJUSTMENT_AMOUNT_TONNES;
            //vReturn = vAdjustment.ADJUSTMENT_AMOUNT_TONNES + 0.00;
        } else if (!chute.MID_SENSOR_VALUE && (vTest > chute.MIDSENSOR_TONNES)) {
            var vAdjustment = {};
            vAdjustment.START_TIME = new Date();
            vAdjustment.MACHINE_OID = chute.MACHINE_OID;
            vAdjustment.MACHINE_NAME = "" + chute.MACHINE_NAME;
            vAdjustment.ADJUSTMENT_AMOUNT_TONNES = -(vTest - chute.MIDSENSOR_TONNES);
            vAdjustment.ADJUSTMENT_DESCRIPTION = "Moving Level down to Sensor Level";
            vAdjustment.ADJUSTMENT_SOURCE = "SENSORCHUTE";
            vAdjustment.ADJUSTMENT_TYPE = "MID_SENSOR";
            var vResult = await storeFMIChuteAdjustment(vAdjustment);
            //return vAdjustment.ADJUSTMENT_AMOUNT_TONNES;
            return chute.MID_SENSOR_ADJUSTMENT_TONNES + vAdjustment.ADJUSTMENT_AMOUNT_TONNES;
            //vReturn = vAdjustment.ADJUSTMENT_AMOUNT_TONNES + 0.00;
        }
    }
    //var vAfterTest = vCalcLevel + chute.MID_SENSOR_ADJUSTMENT_TONNES;
    //console.log("FMICHUTE:CalcSensorLevel: With Sensor Level Adjust Before["+vTest+"]AfterCheck["+vAfterTest+"].");
    //return chute.MID_SENSOR_ADJUSTMENT_TONNES;
    return chute.MID_SENSOR_ADJUSTMENT_TONNES;
}

function authentication(req, res, next) {
    var authheader = req.headers.authorization;
    //console.log(req.headers);

    if (!authheader) {
        var err = new Error('You are not authenticated!');
        res.setHeader('WWW-Authenticate', 'Basic');
        err.status = 401;
        return next(err)
    }

    var auth = new Buffer.from(authheader.split(' ')[1],
        'base64').toString().split(':');
    var user = auth[0];
    var pass = auth[1];

    var vAuthenticated = false;
    var vLogin = config.get('login');
    //console.log("LOGIN:"+JSON.stringify(vLogin));
    for (vUser in vLogin) {
        //console.log("USER:"+JSON.stringify(vLogin[vUser]));
        if (user == vLogin[vUser].user && pass == vLogin[vUser].passwd) {
            console.log("LOGGED IN: " + JSON.stringify(user) + ".");
            // If Authorized user
            vAuthenticated = true;
            next();
        }
    }
    if (!vAuthenticated) {
        var err = new Error('You are not authenticated!');
        res.setHeader('WWW-Authenticate', 'Basic');
        err.status = 401;
        return next(err);
    }
}

app.use(authentication);
app.use(bodyParser.json()); // for parsing application/json
app.use(bodyParser.urlencoded({
    extended: true
}));

var vDataStoreCount = 0;
var vDataStoreFailCount = 0;
var vDataInputCount = 0;
var vDataInputRequestCount = 0;
var vDataOutputCount = 0;
var vDataOutputRequestCount = 0;

//Lets update a Zone Feature
app.post('/api/createFMIChuteUpdate', async (req, res) => {
    var vFLTChuteUpdate = req.body;
    var vResult = 0;
    console.log("FLTChute:createFLTChuteUpdate Update Received[" + JSON.stringify(vFLTChuteUpdate) + "]");
    if (vFLTChuteUpdate.type === "ADJUSTMENT") {
        var vAdjustment = {};
        vAdjustment.START_TIME = new Date();
        vAdjustment.MACHINE_OID = parseInt(vFLTChuteUpdate.machine_oid);
        vAdjustment.MACHINE_NAME = "" + vFLTChuteUpdate.machine_name;
        vAdjustment.ADJUSTMENT_AMOUNT_TONNES = parseFloat(vFLTChuteUpdate.adjustment_amount_tonnes) + 0.00;
        vAdjustment.ADJUSTMENT_DESCRIPTION = "" + vFLTChuteUpdate.adjustment_description;
        var vUser = new Buffer.from(req.headers.authorization.split(' ')[1], 'base64').toString().split(':')[0];
        vAdjustment.ADJUSTMENT_SOURCE = "API-" + vUser;
        vAdjustment.ADJUSTMENT_TYPE = "MANUAL";
        if (vCompleteChuteData.has(vAdjustment.MACHINE_NAME)) {
            //Now lets update the current live data.
            var vLP = vCompleteChuteData.get(vAdjustment.MACHINE_NAME);
            vLP.FMI_ADJUSTMENT_TONNES += vAdjustment.ADJUSTMENT_AMOUNT_TONNES;
            vLP.CALCULATED_LEVEL_TONNES = calcCalcLevel(vLP);
            vLP.CURRENT_LEVEL_TONNES = calcCurrentLevel(vLP);
            vCompleteChuteData.set(vAdjustment.MACHINE_NAME, vLP);
            //Now Lets udpate the history live graph.
            var vNewLP = JSON.parse(JSON.stringify(vLP));
            vNewLP.START_TIME = vAdjustment.START_TIME;
            vNewLP.ID = [...vMAPFMIChuteHistoricalData.keys()].pop() + 1;
            vNewLP.MACHINE_OID = vAdjustment.MACHINE_OID;
            vMAPFMIChuteHistoricalData.set(vNewLP.ID, vNewLP);
        }
        vResult = storeFMIChuteAdjustment(vAdjustment);
    } else if (vFLTChuteUpdate.type === "INITIAL") {
        if (vFMIChuteData.has(vFLTChuteUpdate.machine_name)) {
            var vChute = vFMIChuteData.get(vFLTChuteUpdate.machine_name);
            vChute.INITIAL_LEVEL_TONNES = parseFloat(vFLTChuteUpdate.adjustment_amount_tonnes) + 0.00;
            vFMIChuteData.set(vFLTChuteUpdate.machine_name, vChute);
            if (vCompleteChuteData.has(vFLTChuteUpdate.machine_name)) {
                //Now lets update the current live data.
                var vLP = vCompleteChuteData.get(vFLTChuteUpdate.machine_name);
                vLP.INITIAL_LEVEL_TONNES = parseFloat(vFLTChuteUpdate.adjustment_amount_tonnes) + 0.00;
                vLP.CALCULATED_LEVEL_TONNES = calcCalcLevel(vLP);
                vLP.CURRENT_LEVEL_TONNES = calcCurrentLevel(vLP);
                vCompleteChuteData.set(vFLTChuteUpdate.machine_name, vLP);
                //Now Lets udpate the history live graph.
                var vNewLP = JSON.parse(JSON.stringify(vLP));
                vNewLP.START_TIME = new Date();
                vNewLP.ID = [...vMAPFMIChuteHistoricalData.keys()].pop() + 1;
                vNewLP.MACHINE_OID = parseInt(vFLTChuteUpdate.machine_oid);;
                vMAPFMIChuteHistoricalData.set(vNewLP.ID, vNewLP);
            }

            vResult = await storeFMIChute(vChute);
        }
    } else if (vFLTChuteUpdate.type === "SETTING_CHANGE") {
        if (vFLTChuteUpdate.setting === "USE_MID_SENSOR") {
            if (vFMIChuteData.has(vFLTChuteUpdate.machine_name)) {
                var vMachineName = "" + vFLTChuteUpdate.machine_name;
                //Lets store the setting change
                var vSetting = {}
                vSetting.MACHINE_NAME = "" + vMachineName;
                vSetting.USE_MID_SENSOR = (vFLTChuteUpdate.value === 'true');
                vResult = storeFMIChuteSettings(vSetting);
                //Now lets update the current live data.
                vFMIChuteData.get(vMachineName).USE_MID_SENSOR = (vFLTChuteUpdate.value === 'true');
                if (vCompleteChuteData.has(vMachineName)) {
                    var vChute = vCompleteChuteData.get(vMachineName);
                    vChute.USE_MID_SENSOR = (vFLTChuteUpdate.value === 'true');
                    //vChute = await calcSensorLevel(vChute,vChute.CURRENT_LEVEL_TONNES);
                    //var vCalcCurrent = calcCurrentLevel(vChute);
                    //vChute.MID_SENSOR_ADJUSTMENT_TONNES += await calcSensorLevel(vChute,vCalcCurrent);
                    vCompleteChuteData.set(vMachineName, vChute);
                    //if ( vChute.CURRENT_LEVEL_TONNES !=vCalcCurrent){
                    //Now Lets udpate the history live graph.
                    //	var vNewLP = JSON.parse(JSON.stringify(vChute));
                    //	vNewLP.START_TIME=new Date();
                    //	vNewLP.ID=[...vMAPFMIChuteHistoricalData.keys()].pop() + 1;
                    //vNewLP.MACHINE_OID=vAdjustment.MACHINE_OID;
                    //	vMAPFMIChuteHistoricalData.set(vNewLP.ID,vNewLP);
                    //}
                    //
                }
            }
        }
    }
    //vFMIZones.features.push(vNewZone);
    res.json(vResult); //{ id: vNewZone.id});
});

app.get('/api/getFMIChute', (req, res) => {
    var vReturnData = utils.getArray(vCompleteChuteData);
    vReturnData = filter.doFilters(vReturnData, req);
    res.send(vReturnData);
    //Stats
    vDataOutputRequestCount++;
    vDataOutputCount = vDataOutputCount + vReturnData.length;
});

app.get('/api/getFMIChuteHistory', (req, res) => {
    var vReturnData = utils.getArray(vMAPFMIChuteHistoricalData);
    vReturnData = filter.doFilters(vReturnData, req);
    res.send(vReturnData);
    //Stats
    vDataOutputRequestCount++;
    vDataOutputCount = vDataOutputCount + vReturnData.length;
});

app.get('/api/getAppStatusFMIChute', (req, res) => {
    var vAppStatus = {};
    vAppStatus.Name = "FMIChute";
    vAppStatus.Version = APP_VERSION;
    vAppStatus.DataStoreSize = vMAPFMIChuteHistoricalData.size;
    vAppStatus.DataStoreCount = vDataStoreCount;
    vAppStatus.DataStoreFailCount = vDataStoreFailCount;
    vAppStatus.DataInputCount = vDataInputCount;
    vAppStatus.DataInputRequestCount = vDataInputRequestCount;
    vAppStatus.DataOutputCount = vDataOutputCount;
    vAppStatus.DataOutputRequestCount = vDataOutputRequestCount;
    vAppStatus.UsageMemory = process.memoryUsage();
    vAppStatus.UsageCPU = process.cpuUsage();
    vAppStatus.CPU = vCPUPercent;
    res.send(vAppStatus);
});

console.log("FMICHUTE:Starting API endpoints...");
var server = http.createServer(app);
server.listen(PORT, function() {
    console.log('FMICHUTE:Server running, version ' + APP_VERSION + ', Express is listening... at ' + PORT + " for requests");
});
setInterval(loadHistoryData, vLoadDataInterval); // Now it starts the same thing.
setInterval(loadData, vLoadDataInterval); // Now it starts the same thing.
//
