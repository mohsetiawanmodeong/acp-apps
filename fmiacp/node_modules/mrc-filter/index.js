exports.doTest = function() {
        console.log("mrc-filter Test Function.");
}

//Exclusive
function timeFilterData(data, vGTimeStart, vGTimeEnd, vTimeInclusion){
	if (vTimeInclusion === "start" ){
		return starttimeFilterData(data, vGTimeStart, vGTimeEnd);
	}else if (vTimeInclusion === "end" ){
		return endtimeFilterData(data, vGTimeStart, vGTimeEnd);
	}else if (vTimeInclusion === "contain" ){
                return containtimeFilterData(data, vGTimeStart);
        }else if (vTimeInclusion === "either" ){
                return eithertimeFilterData(data, vGTimeStart,vGTimeEnd);
        }
	return bothtimeFilterData(data, vGTimeStart, vGTimeEnd);
}

function containtimeFilterData(data, vGTimeStart){
                var vReturnData = [];
                data.forEach((datavalue,index,array) => {
                        if ( Date.parse(datavalue.START_TIME) < vGTimeStart ) {
                                 if (( Date.parse(datavalue.END_TIME) > vGTimeStart ) || ( datavalue.END_TIME === null )) {
                                 	vReturnData.push(datavalue);
                                 }
                        }
                });
                console.log("Before Contain Time Filter("+vGTimeStart+")("+data.length+")after("+vReturnData.length+").");
                return vReturnData;
}

function bothtimeFilterData(data, vGTimeStart, vGTimeEnd){
                var vReturnData = [];
                data.forEach((datavalue,index,array) => {
                        if ( Date.parse(datavalue.START_TIME) > vGTimeStart ) {
                                 if (( Date.parse(datavalue.END_TIME) < vGTimeEnd ) || ( vGTimeEnd === null )) {
                                 	vReturnData.push(datavalue);
                                 }
                        }
                });
                console.log("Before Both Time Filter("+vGTimeStart+")("+vGTimeEnd+")("+data.length+")after("+vReturnData.length+").");
                return vReturnData;
}

function eithertimeFilterData(data, vGTimeStart, vGTimeEnd){
                var vReturnData = [];
                data.forEach((datavalue,index,array) => {
                        var vInclude=false;
                        if ( Date.parse(datavalue.START_TIME) > vGTimeStart ) {
                                 if (( Date.parse(datavalue.START_TIME) < vGTimeEnd ) || ( vGTimeEnd === null )) {
                                        vInclude=true;
                                 }
                        }
                        if (( Date.parse(datavalue.END_TIME) < vGTimeEnd ) || ( vGTimeEnd === null )) {
                                 if ( Date.parse(datavalue.END_TIME) > vGTimeStart ) {
                                        vInclude=true;
                                 }
                        }
                        //Now lets handle current values that have a null endtime
                        if (( Date.parse(datavalue.START_TIME) < vGTimeEnd ) && ( datavalue.END_TIME === null )) {
                                vInclude=true;
                        }
                        if (vInclude){
                                vReturnData.push(datavalue);
                        }
                });
                console.log("Before Either Time Filter("+vGTimeStart+")("+vGTimeEnd+")("+data.length+")after("+vReturnData.length+").");
                return vReturnData;
}

function starttimeFilterData(data, vGTimeStart, vGTimeEnd){
                var vReturnData = [];
                data.forEach((datavalue,index,array) => {
                        if ( Date.parse(datavalue.START_TIME) > vGTimeStart ) {
                                 if (( Date.parse(datavalue.START_TIME) < vGTimeEnd ) || ( vGTimeEnd === null )) {
                                 	vReturnData.push(datavalue);
                                 }
                        }
                });
                console.log("Before Start Time Filter("+(new Date(vGTimeStart)).toISOString()+")("+vGTimeEnd+")("+data.length+")after("+vReturnData.length+").");
                return vReturnData;
}

function endtimeFilterData(data, vGTimeStart, vGTimeEnd){
                var vReturnData = [];
                data.forEach((datavalue,index,array) => {
                        if ( Date.parse(datavalue.END_TIME) > vGTimeStart ) {
                                 if (( Date.parse(datavalue.END_TIME) < vGTimeEnd ) || ( vGTimeEnd === null )) {
                                 	vReturnData.push(datavalue);
                                 }
                        }
                });
                console.log("Before End Time Filter("+vGTimeStart+")("+vGTimeEnd+")("+data.length+")after("+vReturnData.length+").");
                return vReturnData;
}

function machineNameFilterData(data, vName){
        var vReturnData = [];
        data.forEach((datavalue,index,array) => {
                if (( datavalue.MACHINE_NAME === vName )||( vName === "" )) {
                        vReturnData.push(datavalue);
                }
        });
        console.log("Before MACHINE_NAME Filter("+vName+")("+data.length+")after("+vReturnData.length+").");
        return vReturnData;
}

function machineNameMatchFilterData(data, vName){
        var vReturnData = [];
        var vNewRegExp = new RegExp(vName);
        data.forEach((datavalue,index,array) => {
                if (( vName === "" )||vNewRegExp.test(datavalue.MACHINE_NAME)) {
                        vReturnData.push(datavalue);
                }
        });
        console.log("Before MACHINE_NAME Match Filter("+vName+")("+data.length+")after("+vReturnData.length+").");
        return vReturnData;
}

function loadingPointFilterData(data, vName){

        var vReturnData = [];
        data.forEach((datavalue,index,array) => {
		//Lets check if the SINK Matches
                if (( datavalue.SINK_TYPE === "ORE_PASS" ) && ( datavalue.SINK_NAME.includes(vName))) {
                        vReturnData.push(datavalue);
                }else if (( datavalue.SOURCE_TYPE === "CHUTE" ) && ( datavalue.SOURCE_NAME.includes(vName))) {
                        vReturnData.push(datavalue);
                }

        });
        console.log("Before LOADING_POINT Filter("+vName+")("+data.length+")after("+vReturnData.length+").");
        return vReturnData;
}

function minDurationFilterData(data, vMinDuration){
        var vReturnData = [];
        data.forEach((datavalue,index,array) => {
		if (( datavalue.START_TIME != null) && (datavalue.END_TIME != null)){
			var vStart = new Date(datavalue.START_TIME).getTime();
			var vEnd = new Date(datavalue.END_TIME).getTime();
			var vDuration = vEnd - vStart;
               		if ( vDuration > vMinDuration ) {
                                        vReturnData.push(datavalue);
                        }
		}
        });
        console.log("Before MINDURATION Filter("+vMinDuration+")("+data.length+")after("+vReturnData.length+").");
        return vReturnData;
}

function isinterimFilterData(data, vInterim){
        var vReturnData = [];
        data.forEach((datavalue,index,array) => {
                if (( String(datavalue.IS_INTERIM) === String(vInterim) )||( vInterim === "" )) {
                        vReturnData.push(datavalue);
                }
        });
        console.log("Before ISINTERIM Filter("+vInterim+")("+data.length+")after("+vReturnData.length+").");
        return vReturnData;
}

function istruckFilterData(data, vTruck){
        var vReturnData = [];
        data.forEach((datavalue,index,array) => {
                if ((( String(datavalue.MACHINE_CLASS_OID) === "197491263" )&&( String(vTruck) === "true" ))||( vTruck=== "")) {
                        vReturnData.push(datavalue);
                }else if (( String(datavalue.MACHINE_CLASS_OID) != "197491263" )&&( String(vTruck) === "false" )) {
                        vReturnData.push(datavalue);
		}
        });
        console.log("Before ISTRUCK Filter("+vTruck+")("+data.length+")after("+vReturnData.length+").");
        return vReturnData;
}

function ispersonnelFilterData(data, vPersonnel){
        var vReturnData = [];
        data.forEach((datavalue,index,array) => {
		var vClassOID = datavalue.MACHINE_CLASS_OID;
		if ( datavalue.properties ){
			if ( datavalue.properties.class_oid ){
				vClassOID = datavalue.properties.class_oid;
			}
		}
                if ((( String(vClassOID) === "666666666" )&&( String(vPersonnel) === "true" ))||( vPersonnel=== "")) {
                        vReturnData.push(datavalue);
                }else if (( String(vClassOID) != "666666666" )&&( String(vPersonnel) === "false" )) {
                        vReturnData.push(datavalue);
                }
        });
        console.log("Before ISPERSONNEL Filter("+vPersonnel+")("+data.length+")after("+vReturnData.length+").");
        return vReturnData;
}

function islhdFilterData(data, vLHD){
        var vReturnData = [];
        data.forEach((datavalue,index,array) => {
                if ((( (String(datavalue.MACHINE_CLASS_OID) === "165040007" )||( String(datavalue.MACHINE_CLASS_OID) === "165040008")||( String(datavalue.MACHINE_CLASS_OID) === "165786385"))&&( String(vLHD) === "true" ))||( vLHD=== "")) {
                        vReturnData.push(datavalue);
                }else if (( (String(datavalue.MACHINE_CLASS_OID) != "165040007" )&&(String(datavalue.MACHINE_CLASS_OID) != "165040008")&&(String(datavalue.MACHINE_CLASS_OID) != "165786385"))&&( String(vLHD) === "false" )) {
                        vReturnData.push(datavalue);
		}
        });
        console.log("Before ISLHD Filter("+vLHD+")("+data.length+")after("+vReturnData.length+").");
        return vReturnData;
}

function islpFilterData(data, vLP){
        var vReturnData = [];
        data.forEach((datavalue,index,array) => {
                if ((( String(datavalue.MACHINE_CLASS_OID) === "165551966" )&&( String(vLP) === "true" ))||( vLP=== "")) {
                        vReturnData.push(datavalue);
                }else if (( String(datavalue.MACHINE_CLASS_OID) != "165551966" )&&( String(vLP) === "false" )) {
                        vReturnData.push(datavalue);
		}
        });
        console.log("Before ISLP Filter("+vLP+")("+data.length+")after("+vReturnData.length+").");
        return vReturnData;
}

function typeFilterData(data, vType){
        var vReturnData = [];
        data.forEach((datavalue,index,array) => {
                if ( String(vType).includes(String(datavalue.TYPE))){ // === String(vType)) {
                        vReturnData.push(datavalue);
                }
        });
        console.log("Before TYPE Filter("+vType+")("+data.length+")after("+vReturnData.length+").");
        return vReturnData;
}

function categoryFilterData(data, vCategory){
        var vReturnData = [];
        data.forEach((datavalue,index,array) => {
                if ( String(datavalue.CATEGORY) === String(vCategory)) {
                        vReturnData.push(datavalue);
                }
        });
        console.log("Before CATEGORY Filter("+vCategory+")("+data.length+")after("+vReturnData.length+").");
        return vReturnData;
}


function modeFilterData(data, vMode){
        var vReturnData = [];
        data.forEach((datavalue,index,array) => {
                if ( String(datavalue.MODE) === String(vMode)) {
                        vReturnData.push(datavalue);
                }
        });
        console.log("Before MODE Filter("+vMode+")("+data.length+")after("+vReturnData.length+").");
        return vReturnData;
}

function modeActiveFilterData(data, vModeActive){
        var vReturnData = [];
        data.forEach((datavalue,index,array) => {
                if ( String(datavalue.MODE_ACTIVE) === String(vModeActive)) {
                        vReturnData.push(datavalue);
                }
        });
        console.log("Before MODE_ACTIVE Filter("+vModeActive+")("+data.length+")after("+vReturnData.length+").");
        return vReturnData;
}

function activeFilterData(data, vActive){
        var vReturnData = [];
        data.forEach((datavalue,index,array) => {
                if ( String(datavalue.ACTIVE) === String(vActive)) {
                        vReturnData.push(datavalue);
                }
        });
        console.log("Before ACTIVE Filter("+vActive+")("+data.length+")after("+vReturnData.length+").");
        return vReturnData;
}

function machinecountFilterData(data, vCount){
        var vReturnData = [];
	var vCounts= new Map();
        data.slice().reverse().forEach((datavalue,index,array) => {
		if ( vCounts.has(datavalue.MACHINE_NAME)){
			var vTmp = vCounts.get(datavalue.MACHINE_NAME)+1;
			vCounts.set(datavalue.MACHINE_NAME, vTmp);
		}else{
			vCounts.set(datavalue.MACHINE_NAME, 1);
		}
		if ( vCounts.get(datavalue.MACHINE_NAME) <= vCount ){
                        vReturnData.push(datavalue);
                }
        });
        console.log("Before Count Filter("+vCount+")("+data.length+")after("+vReturnData.length+").");
        return vReturnData.slice().reverse();
}

function novalueFilterData(data, vNoValue){
        var vReturnData = [];
        if (vNoValue==="true"){
                data.forEach((datavalue,index,array) => {
                        datavalue.VALUE="";
                        vReturnData.push(datavalue);
                });
                console.log("Finished Blanking Values.");
                return vReturnData;
        }else{
                return data;
        }
}

function sortFilterData(data, vSortField){
        var vReturnData = [];
        if (vSortField==="end"){
		vReturnData = data.sort((obj1, obj2) =>
                        new Date(obj1.END_TIME) - new Date(obj2.END_TIME),
		);
                console.log("Finished Sorting by End.");
                return vReturnData;
        }else if (vSortField==="start"){
                vReturnData = data.sort((obj1, obj2) =>
                        new Date(obj1.START_TIME) - new Date(obj2.START_TIME),
                );
                console.log("Finished Sorting by Start.");
                return vReturnData;
        }else{
                return data;
        }
}

exports.doFiltersCopilot = function copilotFilterData(data, vName, vMAPCMDMachineList, vMAPMSCopilot){
        var vReturnData = [];
        data.forEach((datavalue,index,array) => {
		if (vMAPCMDMachineList.has(datavalue.MACHINE_NAME)){
			var vReturn=false;
			if ( vName === "FLTCYCLE" ) {
				if ( vMAPMSCopilot.has(datavalue.OID) ) {
					vCOMPLETED = vMAPMSCopilot.get(datavalue.OID).COMPLETED;
					vLastUpdate = vMAPMSCopilot.get(datavalue.OID).LAST_UPDATE;
					if (vCOMPLETED != 1){
						//( vCOMPLETED == false ) || ( vCOMPLETED == null) || !vCOMPLETED ) {
						vReturn=true;
					}
					if ( (new Date(datavalue.LAST_UPDATE).getTime()) > (new Date(vLastUpdate).getTime())){
						 vReturn=true;
                                        }
				}else{
                        		vReturn=true;
				}
			}

			if ( vName === "FLTACTIVITY" ) {
				if ( vMAPMSCopilot.has(datavalue.CYCLE_OID) ) {
                                	vCOMPLETED = vMAPMSCopilot.get(datavalue.CYCLE_OID).COMPLETED;
                                	vLastUpdate = vMAPMSCopilot.get(datavalue.CYCLE_OID).LAST_UPDATE;
					if (vCOMPLETED != 1){
						//( vCOMPLETED == false ) || ( vCOMPLETED == null) || !vCOMPLETED ) {
						vReturn=true;
					}
                                	if ( (new Date(datavalue.LAST_UPDATE).getTime()) > (new Date(vLastUpdate).getTime())){
                                        	vReturn=true;
                                	}
                        	}else{
                                	vReturn=true;
                        	}
			}

			if ( vName === "CMDEVENT" ) {
				//vReturn=true;
				//var vLastUpdate = (vLastUpdateMSCopilot - (1*86400000));
				//if ( (new Date(datavalue.LAST_UPDATE).getTime()) > vLastUpdate ){
					//Lets send the last 1 days of event updates.
					vReturn=true;
				//}
			}

			if (vReturn){
				vReturnData.push(datavalue);
			}
		}
        });
        console.log("Before Copilot Filter("+vName+")("+data.length+")after("+vReturnData.length+").");
        return vReturnData;
}

exports.doFilters = function (vReturnData, req){
	var vStartDateTime;
	var vEndDateTime;
	var vTimeInclusion="all";
	//Get DateTime Range Parameter Values
	if ( req.query.startdatetime ) { vStartDateTime= Date.parse(req.query.startdatetime); }
	if ( req.query.enddatetime ) { vEndDateTime= Date.parse(req.query.enddatetime); }
	if ( req.query.timeinclusion ) { vTimeInclusion = req.query.timeinclusion; }
	//Do Value Filters
	if ( req.query.machine_name )   { vReturnData = machineNameFilterData(vReturnData,req.query.machine_name); }
	if ( req.query.machine_name_match )   { vReturnData = machineNameMatchFilterData(vReturnData,req.query.machine_name_match); }
	if ( req.query.loading_point )   { vReturnData = loadingPointFilterData(vReturnData,req.query.loading_point); }
	//if ( req.query.copilot ) { vReturnData = copilotFilterData(vReturnData,req.query.copilot); }
	if ( req.query.minduration ) { vReturnData = minDurationFilterData(vReturnData,req.query.minduration); }
	if ( req.query.isinterim ) { vReturnData = isinterimFilterData(vReturnData,req.query.isinterim); }
	if ( req.query.istruck ) { vReturnData = istruckFilterData(vReturnData,req.query.istruck); }
	if ( req.query.ispersonnel ) { vReturnData = ispersonnelFilterData(vReturnData,req.query.ispersonnel); }
	if ( req.query.islhd ) { vReturnData = islhdFilterData(vReturnData,req.query.islhd); }
	if ( req.query.islp ) { vReturnData = islpFilterData(vReturnData,req.query.islp); }
	if ( req.query.type ) { vReturnData = typeFilterData(vReturnData,req.query.type); }
	if ( req.query.category ) { vReturnData = categoryFilterData(vReturnData,req.query.category); }
	if ( req.query.mode ) { vReturnData = modeFilterData(vReturnData,req.query.mode); }
	if ( req.query.mode_active ) { vReturnData = modeActiveFilterData(vReturnData,req.query.mode_active); }
	if ( req.query.active ) { vReturnData = activeFilterData(vReturnData,req.query.active); }
	if ( req.query.machinecount ) { vReturnData = machinecountFilterData(vReturnData,req.query.machinecount); }
	if ( req.query.novalue ) { vReturnData = novalueFilterData(vReturnData,req.query.novalue); }
	//Do DateTimeRange Filters
	if ( !isNaN(vStartDateTime) )
	{
			if ( !isNaN(vEndDateTime) )
			{
					if ( vStartDateTime < vEndDateTime )
					{
							vReturnData = timeFilterData(vReturnData,vStartDateTime,vEndDateTime,vTimeInclusion);
					}else {
							vReturnData = timeFilterData(vReturnData,vStartDateTime,null,vTimeInclusion);
					}
			}else{
					vReturnData = timeFilterData(vReturnData,vStartDateTime,null,vTimeInclusion);
			}
	}
	//Do Sorting
	if ( req.query.sort ) { vReturnData = sortFilterData(vReturnData,req.query.sort); }
	return vReturnData;
}
